/////////////////////////////////////////DAY8///////////////////////////////////////////////
▣ 상속(Inheritance)
	- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것	
	- 추상화
		각 클래스들의 필드가 공통적으로 들어가는 것을 말한다. -> 이 공통점들을 하나로 묶어논다.

	- 부모 클래스에 있는 필드들은 자식 클래스의 필드들에 다 상속됨.
	- 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 쉽다.
	- 코드의 재사용성을 높이고 코드의 중복을 제거함
	
	class 자식클래스 extends 부모클래스{}
	- 자바는 다중상속을 지원하지 않는다.
	   불가능: class 자식클래스 extends 부모클래스1, 부모클래스2{}
	- 부모클래스 = 조상클래스 = 기반(base)클래스
	   자식클래스 = 자손클래스 = 하위클래스 = 파생된 클래스
	
	- 상속이 안되는 것
	  	부모클래스에서 private 접근 제한을 갖는 필드와 메소드
	   	 생성자
		부모클래스와 자식클래스가 다른 패키지가 존재한다면 default 접근제한을 갖는 필드와 메서드
===============================================================================
	- 자식 클래스는 부모 클래스에서 물려받은 멤버(메서드, 필드)를 그대로 사용하거나 변경(오버라이딩= 재정의)
		할 수 있고 새로운 멤버(메서드, 필드)도 추가할 수 있다.
	- 상속받을 때 부모쪽으로 화살표가 됨. 자식 클래스는 부모+자식에서 추가한 것이 됨.
	- super(); -> 부모생성자를 호출한다.
	- 상속 관계 : IS - A(~은 ~이다.)
	  소유 관계(포함관계) : HAS - A(~을 가지고 있다.)
=================================================================================
메서드 overriding(재정의)
	- 부모메서드와 자식메서드에 같은 메서드 함수가 있을 때 자식 메서드가 실행됨. 이것이 오버라이딩임.
		=>부모메서드 위에 자식 메서드를 덮어놓는 개념이 되는 것(부모의 메서드를 없애고 실행하는 것이 아님)
	- 메서드만 오버라이딩이 가능함!
	- 물려 받은 부모 메서드를 자식 클래스에 맞도록 자식에서 수정하는 것(재정의 하는 것)
	1) 메서드 오버라이딩 규칙
		- * 부모클래스의 메서드와 동일한 시그니처(메서드명, 매개타입, 매개변수 개수, 순서)를 사용한다.
		- 반환 타입까지 같아야함
		- 부모 클래스의 메서드보다 접근 범위(접근 제한자 범위)를 더 좁게 할 수 없다. 
	2) 오버라이딩이 불가능한 경우
		- private 메서드 : 부모 클래스의 멤버가 private이면 자식 클래스에 상속되지 않는다.
		- 정적 메서드(객체 안에 존재하지 않고 class안에 존재하기 때문에 불가능함)(static 메서드)
		- final 메서드(어디서든지 상속할 수 없다는 의미임. 자식을 가질 수 없다는 의미. 더 이상 수정할 수 없기 때문)
	3) 오버라이딩(재정의) 된 메서드 위에 @(annotation임)override를 붙여준다.
		- 에러는 나지 않지만 붙여줘야 함.
====================================================================================
모든 클래서의 조상은 Object class임 => 이것은 자동으로 됨.(extends Object를 하지 않아도 자동으로 되는 것)
**자식은 부모타입이 될 수 있다.**
==========================================
다형성(Polymorphism)
	- 1개의 객체를 여러 가지 모양으로 표현할 수 있는 특성
	   (같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질)

		사과[] apple = {new 사과(), new사과()}
		사과[] apple = {new 포도(), new포도()}
		사과[] apple = {new 키위(), new키위(), new키위()}
		=> 이렇게 만들면 너무 복잡해짐
	
		과일[]fruits = {new 사과(), new사과(), new 포도(), new포도(), new 키위(), new키위(), new키위()}
		=> 객체 관리가 편리해짐

	-*부모 타입에 모든 자식개체가 대입될 수 있다. (자식 타입은 부모 타입으로 자동 타입 변환이 가능하다.)
	- 자식은 부모 타입으로 바꿀 수 있다.(upcasting)
		Animal ani = new Tiger(); -> 자동 타입 변환된 것
		//Tiger class에서 Animal에 있는 부분들만 ani에 넣어서 쓰겠다!라는 의미임.
		//Tiger만 있는 것들은 숨겨놓는다.
	- 예외적으로 자식이 한번 부모 타입으로 갔던 것은 다시 자식 타입으로 돌아올 수 있음(downcasting)
		=> 특수한 케이스임
		Tiger ti = new (Tiger)ani;
		이는 강제 형변환이 되는지 안되는지를 instanceof로 확인 가능
1. 객체의 타입(형) 변환
	- 모든 객체를 타입변환할 수 있는 것이 아니라 상속 관계일 때만 가능
	- 자동 타입(형)변환, 강제 타입(형) 변환이 있음
2. 자동 타입(형) 변환
	- 자식 클래스를 부모 클래스로 타입을 변환할 수 있음(up casting)
	- 변환연산자(타입)가 필요 없어 자식 클래스를 부모 클래스로 변환하는 것
	- 1) Animal ani = (Animal) new Cat();//(Animal)이 생략되어서 안보이는 것. 원래 붙어있음
	  2) Cat cat = new Cat();
	     Animal ani = cat; (Animal ani = (Animal)cat;)  
		=> 2가지가 다 같은 방법임
	- 자동 타입 변환은 부모 타입 변수로 자식 객체에 접근할 수 있다.
	- 부모 타입 변수로 부모 타입에 있는 자식 멤버에 접근할 수는 있고, 
		자식 타입에만 있는 자식 멤버에는 접근할 수 없다.
3. 강제 타입(형) 변환
	- 부모 타입의 객체는 자식 타입으로 변환할 수 없다.
	  부모 타입 객체를 자식 클래스로 강제 타입을 변환하면 오류가 발생한다.
	
		Cat cat = new Animal(); => 오류

		Animal ani = new Animal();
		Cat cat = (Cat) ani;  =>오류
	- 자식 객체이지만 부모 타입 변수가 참조하고 있다면 자식 타입으로 변환할 수 있다.
		1) Cat cat = new Cat();
		Animal ani = cat;
		
		Cat cat = (Cat)ani; => 가능 원래 자기 자신으로 돌아온 것이기 때문(자식-> 부모 -> 자식)
		
		2) Animal ani = (Animal) new Cat();
		   Cat cat = (Cat) ani;  =>가능
4. 타입 변환 가능 확인
	- instanceof
		변수 instanceof 타입
		변수가 타입으로 변환할 수 있으면 true, 변환할 수 없으면 false
		변수가 해당 타입과 관련이 없는 것이면 오류 발생

5. 타입 변환을 이용한 다형성
	- 다형성 : 하나의 참조 변수에 여러 객체를 대입해서 다양한 동작을 수행하도록 하는 것
		다양한 객체에 동일한 명령어를 적용해, 객체의 종류에 따라서 다양한 동작을 얻을 수 있다.
	- 자식 객체를 부모 타입 변수에 대입하면 부모 클래스에 선언된 멤버(필드, 메서드)만 볼 수 있다.
	- 부모 클래스에 선언된 메서드를 자식 클래스가 오버라이딩했다면, 부모 타입 변수에 부모 객체의 메서드는 보이지 않고 자식 객체의 메서드만 보인다.
		jvm이 실행단계에서 객체의 실제 타입을 보고 오버라이딩한 메서드를 호출하기 때문(부모메서드 자식메서드 가려진다.)
		변수와 실제 메서드를 실행 도중에 연결하는 것을 동적 바인딩이라고 한다.
	*주의* 부모 클래스의 필드와 정적 메서드는 오버라이딩될 수 없다. => 동적 바인딩과는 관련이 없다.
================================================================================
탈것 => Vechle(부모)
		필드(인스턴스)   name
		인스턴스 메서드 kind()
		static 메서드     move
	Car(자식) 
		필드(인스턴스)   name
		인스턴스 메서드 kind()
		static 메서드     move
	SportCar (Car을 상속받음)
		필드(인스턴스)   kind()
	실행 클래스  PolymorExam